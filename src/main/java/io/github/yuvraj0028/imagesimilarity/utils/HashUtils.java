package io.github.yuvraj0028.imagesimilarity.utils;

import java.awt.image.BufferedImage;

/**
 * Utility class for generating 64-bit perceptual hashes (dHash, Blockhash, pHash) 
 * from images, using the ImageUtils helper class.
 */
public class HashUtils {
    
    // Private constructor to prevent instantiation of this static utility class.
    private HashUtils() {}

    // --- Difference Hash (dHash) ---
    
    /**
     * Generates a 64-bit Difference Hash (dHash).
     * The hash is based on the directional gradient (difference) between adjacent pixels.
     * * @param img The source image.
     * @return The 64-bit dHash value.
     */
    public static long dHash64(BufferedImage img) {
        // 1. Convert to grayscale.
        BufferedImage gray = ImageUtils.toGrayscale(img);
        // 2. Resize to 9x8. The extra column is needed to calculate 8 horizontal differences per row.
        BufferedImage small = ImageUtils.resize(gray, 9, 8);

        long hash = 0L;
        // Iterate through the 8x8 grid of pixel comparisons.
        for (int y = 0; y < 8; y++) {
            for (int x = 0; x < 8; x++) {
                // Get grayscale values of two adjacent pixels (left: x, right: x+1).
                int left = ImageUtils.getGray(small, x, y);
                int right = ImageUtils.getGray(small, x + 1, y);
                
                // Shift the hash left by 1 to make room for the new bit.
                hash <<= 1;
                
                // If the left pixel is brighter than the right, set the bit to 1 (gradient direction).
                // This converts the 64 differences into a binary string.
                if (left > right) hash |= 1L;
            }
        }
        return hash;
    }

    // --- Block Mean Hash (Blockhash) ---
    
    /**
     * Generates a 64-bit Block Mean Hash (similar to a simple average hash but using the median).
     * The hash is generated by comparing each pixel's value in a small image to the median
     * intensity of all pixels in that image.
     * * @param img The source image.
     * @return The 64-bit block hash value.
     */
    public static long blockHash64(BufferedImage img) {
        // 1. Convert to grayscale and resize to 8x8.
        BufferedImage gray = ImageUtils.toGrayscale(img);
        BufferedImage small = ImageUtils.resize(gray, 8, 8);

        // 2. Extract 64 grayscale pixel values.
        int[] vals = new int[64];
        for (int y = 0; y < 8; y++) {
            for (int x = 0; x < 8; x++) {
                vals[y * 8 + x] = ImageUtils.getGray(small, x, y);
            }
        }
        
        // 3. Find the median intensity of all 64 pixels.
        int median = median(vals);
        
        // 4. Generate the 64-bit hash by comparison to the median.
        long hash = 0L;
        for (int i = 0; i < 64; i++) {
            hash <<= 1;
            // If the pixel is brighter than the median, set the bit to 1.
            if (vals[i] > median) hash |= 1L;
        }
        return hash;
    }

    /**
     * Helper method to compute the median of an array of integers.
     */
    private static int median(int[] arr) {
        int[] copy = arr.clone();
        java.util.Arrays.sort(copy);
        // The median is the value at the middle index (for 64 elements, it's index 32).
        return copy[copy.length / 2];
    }

    // --- Perceptual Hash (pHash) ---
    
    /**
     * Generates a 64-bit Perceptual Hash (pHash) using the Discrete Cosine Transform (DCT).
     * pHash is robust against scaling, slight cropping, and color changes.
     * * @param img The source image.
     * @return The 64-bit pHash value.
     */
    public static long pHash64(BufferedImage img) {
        // 1. Convert to grayscale and resize to a larger size, typically 32x32 for DCT.
        BufferedImage gray = ImageUtils.toGrayscale(img);
        BufferedImage small = ImageUtils.resize(gray, 32, 32);

        // 2. Copy the 32x32 pixel values into a 2D double array.
        double[][] vals = new double[32][32];
        for (int y = 0; y < 32; y++) {
            for (int x = 0; x < 32; x++) {
                vals[y][x] = ImageUtils.getGray(small, x, y);
            }
        }

        // 3. Apply the 2D Discrete Cosine Transform (DCT).
        double[][] dct = applyDCT(vals);

        // 4. Extract the top-left 8x8 block (the 64 lowest frequency components).
        double[] top = new double[64];
        int idx = 0;
        // Exclude the DC coefficient (dct[0][0]) for better robustness in pHash, 
        // starting from (0,0) and going up to (7,7).
        for (int y = 0; y < 8; y++) {
            for (int x = 0; x < 8; x++) {
                top[idx++] = dct[y][x];
            }
        }

        // 5. Calculate the median of the 64 selected DCT coefficients.
        double median = median(top);
        
        // 6. Generate the 64-bit hash by comparing the coefficients to the median.
        long hash = 0L;
        for (double v : top) {
            hash <<= 1;
            // If the coefficient is greater than the median, set the hash bit to 1.
            if (v > median) hash |= 1L;
        }
        return hash;
    }

    /**
     * Helper method to compute the median of an array of doubles.
     */
    private static double median(double[] arr) {
        double[] copy = arr.clone();
        java.util.Arrays.sort(copy);
        // Returns the middle element.
        return copy[copy.length / 2];
    }

    /**
     * Computes the 2D Discrete Cosine Transform (DCT) on a square matrix 'f'.
     * This mathematical transformation converts spatial data (pixels) into frequency data.
     * * @param f The N x N input matrix (pixel values).
     * @return The N x N DCT transformed matrix (frequency components).
     */
    private static double[][] applyDCT(double[][] f) {
        int N = f.length;
        double[][] F = new double[N][N];
        double c1 = Math.PI / (2.0 * N);
        
        // Outer loops iterate over the frequency coefficients (u, v).
        for (int u = 0; u < N; u++) {
            for (int v = 0; v < N; v++) {
                double sum = 0.0;
                // Inner loops iterate over the spatial domain (i, j).
                for (int i = 0; i < N; i++) {
                    for (int j = 0; j < N; j++) {
                        // Core DCT formula calculation.
                        sum += f[i][j] * Math.cos((2.0 * i + 1.0) * u * c1) * Math.cos((2.0 * j + 1.0) * v * c1);
                    }
                }
                
                // Normalization factors c_u and c_v (scaled differently if u or v is 0).
                double cu = u == 0 ? 1.0 / Math.sqrt(2) : 1.0;
                double cv = v == 0 ? 1.0 / Math.sqrt(2) : 1.0;
                
                // Final calculation of the DCT coefficient F[u][v].
                F[u][v] = 0.25 * cu * cv * sum;
            }
        }
        return F;
    }
}
